# TmLibrary - TissueMAPS library for distibuted image analysis routines.
# Copyright (C) 2016  Markus D. Herrmann, University of Zurich and Robin Hafen
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
import re
import json

import tmlib.workflow
from tmlib.utils import assert_type
from tmlib.errors import WorkflowDescriptionError
from tmlib.workflow import get_step_args
from tmlib.workflow import get_step_api
from tmlib.workflow import get_step_information
from tmlib.workflow.definition import get_workflow_definition
from tmlib.workflow.args import BatchArguments
from tmlib.workflow.args import SubmissionArguments


class WorkflowDescription(object):

    '''Description of a `TissueMAPS` workflow.

    A workflow consists of a sequence of *stages*, which are themselves
    composed of *steps*. Each *step* is implemented as a subpackage of
    :mod:`tmlib.workflow` represents a collection of computational
    jobs, which can be submitted for parallel execution on a cluster.

    In principle, workflow steps could be arranged in arbitrary order, since
    dependencies for each step are checked dynamically upon execution of the
    workflow. If a required input is not available, because it has not been
    generated by an upstream step, the workflow will fail.
    To avoid unnecessary execution of jobs, we check the workflow description
    provided by users before submitting any jobs. This is achieved using
    definitions provided by instances of
    :class:`WorkflowDefinition <tmlib.workflow.definition.WorkflowDefinition>`.

    '''

    __slots__ = ('type', '_stages', '_definition')

    def __init__(self, type, stages=[]):
        '''
        Parameters
        ----------
        type: str
            workflow type
        stages: List[dict], optional
            description of workflow stages as a mapping of key-value pairs

        Note
        ----
        When no `stages` are provided a default description will be generated
        based on
        :class:`WorkflowDefinition <tmlib.workflow.definition.WorkflowDefinition>`.
        for the specified workflow `type`.
        '''
        self._definition = get_workflow_definition(type)
        self.type = type
        self._stages = list()
        if stages:
            for stage in stages:
                d = WorkflowStageDescription(self.type, **stage)
                self.add_stage(d)
        else:
            for stage in self._definition.stages:
                d = WorkflowStageDescription(self.type, **stage.to_dict())
                self.add_stage(d)

    @property
    def stages(self):
        '''Tuple[tmlib.workflow.description.WorkflowStageDescription]:
        description of each stage of the workflow
        '''
        return tuple(self._stages)

    def add_stage(self, stage):
        '''Adds an additional stage to the workflow.

        Parameters
        ----------
        stage: tmlib.workflow.description.WorkflowStageDescription
            description of the stage that should be added

        Raises
        ------
        WorkflowDescriptionError
            when `stage` is not defined for the workflow type, does already
            exist or is added at the wrong position
        '''
        if not isinstance(stage, WorkflowStageDescription):
            raise TypeError(
                'Argument "stage" must have type %s'
                % WorkflowStageDescription.__name__
            )
        existing_stages = [s.name for s in self._stages]
        if s.name in existing_stages:
            raise WorkflowDescriptionError(
                'Stage "%s" already exists.' % stage.name
            )
        defined_stages = [s.name for s in self._definition.stages]
        try:
            index = defined_stages.index(stage.name)
        except ValueError:
            raise WorkflowDescriptionError(
                'Undefined stage "%s". Defined stages are: "%s"'
                % (stage.name, '", "'.join(defined_stages))
            )
        required_stages = defined_stages[:index]
        for s in required_stages:
            if s not in existing_stages:
                raise WorkflowDescriptionError(
                    'Stage "%s" requires upstream stage "%s".' % (stage.name, s)
                )
        self._stages.append(stage)

    def to_dict(self):
        '''Returns attributes as a mapping of key-value pairs.

        Returns
        -------
        dict
        '''
        return {
            'type': self.type,
            'stages': [s.to_dict() for s in self._stages]
        }

    def jsonify(self):
        '''Serializes the instance to JSON.

        Returns
        -------
        str
            JSON string encoding the description of the workflow as a
            mapping of key-value pairs
        '''
        return json.dumps(self.to_dict())


class WorkflowStageDescription(object):

    '''Description of a TissueMAPS workflow stage.'''

    __slots__ = ('name', 'concurrent', 'active', '_steps', '_definition')

    @assert_type(name='basestring', concurrent='bool')
    def __init__(self, type, name, concurrent, active=True, steps=[]):
        '''
        Parameters
        ----------
        type: str
            name of the workflow type
        name: str
            name of the stage
        concurrent: str
            whether steps should be executed in parallel or sequentially
        active: bool, optional
            whether the stage should be processed
        steps: List[dict], optional
            description of steps in form of key-value pairs

        Note
        ----
        When no `steps` are provided a description with default values
        will be generated based on
        :class:`WorkflowStageDefinition <tmlib.workflow.definition.WorkflowStageDefinition>`
        for the specified workflow `type`.
        '''
        self.name = str(name)
        self.concurrent = concurrent
        self.active = active
        self._definition = get_workflow_definition(type).get_stage(self.name)
        self._steps = list()
        if len(steps) > 0:
            for step in steps:
                BatchArgs, SubmissionArgs = get_step_args(step['name'])
                batch_arg_mapping = {
                    a['name']: a['value'] for a in step['batch_args']
                }
                batch_args = BatchArgs(**batch_arg_mapping)
                submission_arg_mapping = {
                    a['name']: a['value'] for a in step['submission_args']
                }
                submission_args = SubmissionArgs(**submission_arg_mapping)
                ordinal = get(step, 'ordinal', None)
                self.add_step(
                    WorkflowStepDescription(
                        name=step['name'], active=step['active'],
                        batch_args=batch_args, submission_args=submission_args,
                        ordinal=ordinal
                    )
                )
        else:
            for step in self._definition.steps:
                # FIXME: ordinal default value for steps that are not unique?
                self.add_step(WorkflowStepDescription(name=step, active=True))

    @property
    def steps(self):
        '''Tuple[tmlib.workflow.description.WorkflowStepDescriptions]:
        description of each step of the stage
        '''
        return tuple(self._steps)

    def add_step(self, step):
        '''Adds an additional step to the stage.

        Parameters
        ----------
        step: tmlib.workflow.description.WorkflowStepDescription
            description of the step that should be added

        Raises
        ------
        WorkflowDescriptionError
            when `step` is not defined for the stage, does already exist or
            is added at the wrong position
        '''
        if not isinstance(step, WorkflowStepDescription):
            raise TypeError(
                'Argument "step" must have type %s' %
                WorkflowStepDescription.__name__
            )
        for s in self._steps:
            if s.name == step.name:
                raise WorkflowDescriptionError(
                    'Step "%s" already exists.' % step.name
                )
        defined_steps = self._definition.steps
        try:
            index = defined_steps.index(step.name)
        except ValueError:
            raise WorkflowDescriptionError(
                'Undefined step "%s" for stage "%s". Defined steps are: "%s"'
                % (step.name, self.name, '", "'.join(self._definition.steps))
            )
        required_steps = defined_steps[:index]
        for s in required_steps:
            if s not in self._steps:
                raise WorkflowDescriptionError(
                    'Step "%s" requires upstream step "%s".' % (step.name, s)
                )
        self._steps.append(step_description)

    def to_dict(self):
        '''Returns the attributes as key-value pairs.

        Returns
        -------
        dict
        '''
        return {
            'name': self.name,
            'concurrent': self.concurrent,
            'active': self.active,
            'steps': [s.to_dict() for s in self.steps]
        }

    def jsonify(self):
        '''Returns the attributes as key-value pairs encoded as JSON.

        Returns
        -------
        str
            JSON string encoding the description of the stage as a
            mapping of key-value pairs
        '''
        return json.dumps(self.to_dict())


class WorkflowStepDescription(object):

    '''Description of a workflow step.'''

    __slots__ = (
        'name', 'fullname', 'help', 'ordinal', 'active',
        '_batch_args', '_submission_args'
    )

    def __init__(self, name, active=True, ordinal=None, batch_args=None,
            submission_args=None):
        '''
        Parameters
        ----------
        name: str
            name of the step
        active: bool, optional
            whether the step should be processed
        ordinal: int, optional
            position of the step in the workflow
        batch_args: tmlib.workflow.args.BatchArguments, optional
            batch arguments
        submission_args: tmlib.workflow.args.SubmissionArguments, optional
            submission arguments

        Raises
        ------
        WorkflowDescriptionError
            when a provided argument is not a valid argument for the given step
        '''
        self.name = str(name)
        self.fullname, self.help = get_step_information(name)
        self.active = active
        self.ordinal = ordinal
        BatchArgs, SubmissionArgs = get_step_args(name)
        if batch_args is None:
            self.batch_args = BatchArgs()
        else:
            self.batch_args = batch_args
        if submission_args is None:
            self.submission_args = SubmissionArgs()
        else:
            self.submission_args = submission_args

    @property
    def batch_args(self):
        '''tmlib.workflow.args.BatchArguments: batch arguments'''
        return self._batch_args

    @batch_args.setter
    def batch_args(self, value):
        if not isinstance(value, BatchArguments):
            raise TypeError(
                'Attribute "batch_args" must have type '
                'tmlib.workflow.args.BatchArguments'
            )
        self._batch_args = value

    @property
    def submission_args(self):
        '''tmlib.workflow.args.SubmissionArguments: submission arguments'''
        return self._submission_args

    @submission_args.setter
    def submission_args(self, value):
        if not isinstance(value, SubmissionArguments):
            raise TypeError(
                'Attribute "submission_args" must have type '
                'tmlib.workflow.args.SubmissionArguments'
            )
        self._submission_args = value

    def to_dict(self):
        '''Returns attributes as key-value pairs.

        Returns
        -------
        dict
        '''
        return {
            'name': self.name,
            'fullname': self.fullname,
            'help': self.help,
            'active': self.active,
            'ordinal': self.ordinal,
            'batch_args': self.batch_args.to_list(),
            'submission_args': self.submission_args.to_list()
        }

    def jsonify(self):
        '''Returns attributes as key-value pairs encoded as JSON.

        Returns
        -------
        str
            JSON string encoding the description of the step as a
            mapping of key-value pairs
        '''
        return json.dumps(self.to_dict())
